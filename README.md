# js-algorithm
Use js to implement leetcode algorithm

| 题目编号(topic number)                                       | 文件名(file name)                                            | 描述                                                         | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1~50                                                         | [General-Questions-Part1](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part1) | 普通题：题1到题50归档集合                                    | GeneralQuestion：Question 1 to Question 50 archive collection |
| 51~100                                                       | [General-Questions-Part2](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part2) | 普通题：题51到题100归档集合                                  | GeneralQuestion：Question 51 to Question 100 archive collection |
| [#101](https://leetcode.cn/problems/symmetric-tree/)         | [SymmetricTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/101.SymmetricTree.js) | 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。          | Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). |
| [#102](https://leetcode.cn/problems/binary-tree-level-order-traversal/) | [BinaryTreeLevelOrderTraversal](https://github.com/JunLiangWangX/js-algorithm/blob/main/102.BinaryTreeLevelOrderTraversal.js) | 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。 | Given the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level). |
| [#103](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/) | [BinaryTreeZigzagLevelOrder....](https://github.com/JunLiangWangX/js-algorithm/blob/main/103.BinaryTreeZigzagLevelOrderTraversal.js) | 给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 | Given the `root` of a binary tree, return *the zigzag level order traversal of its nodes' values*. (i.e., from left to right, then right to left for the next level and alternate between). |
| [#104](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | [MaximumDepthofBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/104.MaximumDepthofBinaryTree.js) | 给定一个二叉树 `root` ，返回其最大深度。                     | Given the `root` of a binary tree, return *its maximum depth*. |
| [#105](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | [ConstructBinaryTree....](https://github.com/JunLiangWangX/js-algorithm/blob/main/105.ConstructBinaryTreefromPreorderandInorderTraversal.js) | 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。 | Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return *the binary tree*. |
| [#106](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/) | [ConstructBinaryTree....](https://github.com/JunLiangWangX/js-algorithm/blob/main/106.ConstructBinaryTreefromInorderandPostorderTraversal.js) | 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。 | Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return *the binary tree*. |
| [#107](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/) | [BinaryTreeLevelOrderTraversalII](https://github.com/JunLiangWangX/js-algorithm/blob/main/107.BinaryTreeLevelOrderTraversalII.js) | 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） | Given the `root` of a binary tree, return *the bottom-up level order traversal of its nodes' values*. (i.e., from left to right, level by level from leaf to root). |
| [#108](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/) | [ConvertSortedArraytoBinary....](https://github.com/JunLiangWangX/js-algorithm/blob/main/108.ConvertSortedArraytoBinarySearchTree.js) | 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。 | Given an integer array `nums` where the elements are sorted in **ascending order**, convert *it to a* **height-balanced** *binary search tree*. |
| [#109](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/) | [ConvertSortedListtoBinary....](https://github.com/JunLiangWangX/js-algorithm/blob/main/109.ConvertSortedListtoBinarySearchTree.js) | 给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。 | Given the `head` of a singly linked list where elements are sorted in **ascending order**, convert *it to a* ***height-balanced\*** *binary search tree*. |
| [#110](https://leetcode.cn/problems/balanced-binary-tree/description/) | [BalancedBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/110.BalancedBinaryTree.js) | 给定一个二叉树，判断它是否是高度平衡的二叉树。               | Given a binary tree, determine if it is **height-balanced**. |
| [#111](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) | [MinimumDepthOfBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/111.MinimumDepthOfBinaryTree.js) | 给定一个二叉树，找出其最小深度。                             | Given a binary tree, find its minimum depth.                 |
| [#112](https://leetcode.cn/problems/path-sum/)               | [PathSum](https://github.com/JunLiangWangX/js-algorithm/blob/main/112.PathSum.js) | 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。 | Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`. |
| [#113](https://leetcode.cn/problems/path-sum-ii/)            | [PathSumII](https://github.com/JunLiangWangX/js-algorithm/blob/main/113.PathSumII.js) | 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。 | Given the `root` of a binary tree and an integer `targetSum`, return *all **root-to-leaf** paths where the sum of the node values in the path equals* `targetSum`*. Each path should be returned as a list of the node **values**, not node references*. |
| [#114](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/) | [FlattenBinaryTreetoLinkedList](https://github.com/JunLiangWangX/js-algorithm/blob/main/114.FlattenBinaryTreetoLinkedList.js) | 给你二叉树的根结点 `root` ，请你将它展开为一个单链表：       | Given the `root` of a binary tree, flatten the tree into a "linked list" |
| [#115](https://leetcode.cn/problems/distinct-subsequences/description/) | [DistinctSubsequences](https://github.com/JunLiangWangX/js-algorithm/blob/main/115.DistinctSubsequences.js) | 给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数。 | Given two strings `s` and `t`, return *the number of distinct* ***subsequences\*** *of* `s` *which equals* `t`. |
| [#116](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) | [PopulatingNextRightPointersin....](https://github.com/JunLiangWangX/js-algorithm/blob/main/116.PopulatingNextRightPointersinEachNode.js) | 给定一个 **完美二叉树**,填充它的每个 next 指针，让这个指针指向其下一个右侧节点。 | given a **perfect binary tree**,Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. |
| [#117](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/) | [PopulatingNextRightPointersin...II](https://github.com/JunLiangWangX/js-algorithm/blob/main/117.PopulatingNextRightPointersinEachNodeII.js) | 给定一个**二叉树**,填充它的每个 next 指针，让这个指针指向其下一个右侧节点。 | given a **binary tree**,Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. |
| [#118](https://leetcode.cn/problems/pascals-triangle/description/) | [Pascal'sTriangle](https://github.com/JunLiangWangX/js-algorithm/blob/main/118.Pascal'sTriangle.js) | 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。 | Given an integer `numRows`, return the first numRows of **Pascal's triangle**. |
| [#119](https://leetcode.cn/problems/pascals-triangle-ii/description/) | [[Pascal'sTriangleII](https://leetcode.cn/problems/pascals-triangle-ii/)](https://github.com/JunLiangWangX/js-algorithm/blob/main/119.Pascal'sTriangleII.js) | 给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。 | Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**. |
| [#120](https://leetcode.cn/problems/triangle/description/)   | [Triangle](https://github.com/JunLiangWangX/js-algorithm/blob/main/120.Triangle.js) | 给定一个三角形 `triangle` ，找出自顶向下的最小路径和。       | Given a `triangle` array, return *the minimum path sum from top to bottom*. |
| [#121](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/) | [BestTimetoBuyandSellStock](https://github.com/JunLiangWangX/js-algorithm/blob/main/121.BestTimetoBuyandSellStock.js) | 给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。 | You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock. |
| [#122](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/) | [BestTimetoBuyandSellStockII](https://github.com/JunLiangWangX/js-algorithm/blob/main/122.BestTimetoBuyandSellStockII.js) | 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。返回 *你能获得的 **最大** 利润* 。 | You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.On each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.Find and return *the **maximum** profit you can achieve*. |
| [#123](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) | [BestTimetoBuyandSellStockIII](https://github.com/JunLiangWangX/js-algorithm/blob/main/123.BestTimetoBuyandSellStockIII.js) | 给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。 | You are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete at most two transactions. |
| [#124](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/) | [BinaryTreeMaximumPathSum](https://github.com/JunLiangWangX/js-algorithm/blob/main/124.BinaryTreeMaximumPathSum.js) | 二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。 | A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.The **path sum** of a path is the sum of the node's values in the path.Given the `root` of a binary tree, return *the maximum **path sum** of any **non-empty** path*. |
| [#125](https://leetcode.cn/problems/valid-palindrome/description/) | [ValidPalindrome](https://github.com/JunLiangWangX/js-algorithm/blob/main/125.ValidPalindrome.js) | 给你一个字符串 s，移除所有非字母数字字符之后，如果它是 回文串 ，返回 true ；否则，返回 false 。 | Given a string `s`, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters,return `true` *if it is a **palindrome**, or* `false` *otherwise*. |
| [#126](https://leetcode.cn/problems/word-ladder-ii/description/) | [WordLadderII](https://github.com/JunLiangWangX/js-algorithm/blob/main/126.WordLadderII.js) | 给你两个单词 `beginWord` 和 `endWord` ，以及一个字典 `wordList` 。请你找出并返回所有从 `beginWord` 到 `endWord` 的 **最短转换序列** ，如果不存在这样的转换序列，返回一个空列表。 | Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return *all the **shortest transformation sequences** from* `beginWord` *to* `endWord`*, or an empty list if no such sequence exists.* |
| [#127](https://leetcode.cn/problems/word-ladder/description/) | [WordLadder](https://github.com/JunLiangWangX/js-algorithm/blob/main/127.WordLadder.js) | 给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，返回 *从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。如果不存在这样的转换序列，返回 `0` 。 | Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return *the **number of words** in the **shortest transformation sequence** from* `beginWord` *to* `endWord`*, or* `0` *if no such sequence exists.* |
| [#128](https://leetcode.cn/problems/longest-consecutive-sequence/description/) | [LongestConsecutiveSequence](https://github.com/JunLiangWangX/js-algorithm/blob/main/128.LongestConsecutiveSequence.js) | 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 | Given an unsorted array of integers `nums`, return *the length of the longest consecutive elements sequence.* |
| [#129](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/) | [SumRoottoLeafNumbers](https://github.com/JunLiangWangX/js-algorithm/blob/main/129.SumRoottoLeafNumbers.js) | 给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。每条从根节点到叶节点的路径都代表一个数字：  例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。计算从根节点到叶节点生成的 **所有数字之和** 。 | You are given the `root` of a binary tree containing digits from `0` to `9` only.Each root-to-leaf path in the tree represents a number.For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.Return *the total sum of all root-to-leaf numbers*. Test cases are generated so that the answer will fit in a **32-bit** integer.A **leaf** node is a node with no children. |
| [#130](https://leetcode.cn/problems/surrounded-regions/description/) | [SurroundedRegions](https://github.com/JunLiangWangX/js-algorithm/blob/main/130.SurroundedRegions.js) | 给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。 | Given an `m x n` matrix `board` containing `'X'` and `'O'`, *capture all regions that are 4-directionally surrounded by* `'X'`.A region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region. |
| [#131](https://leetcode.cn/problems/palindrome-partitioning/description/) | [PalindromePartitioning](https://github.com/JunLiangWangX/js-algorithm/blob/main/131.PalindromePartitioning.js) | 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。 | Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return *all possible palindrome partitioning of* `s`. |
| [#132](https://leetcode.cn/problems/palindrome-partitioning-ii/description/) | [PalindromePartitioningII](https://github.com/JunLiangWangX/js-algorithm/blob/main/132.PalindromePartitioningII.js) | 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文。返回符合要求的 **最少分割次数** 。 | Given a string `s`, partition `s` such that every substring of the partition is a palindrome.Return *the **minimum** cuts needed for a palindrome partitioning of* `s`. |
| [#133](https://leetcode.cn/problems/clone-graph/description/) | [CloneGraph](https://github.com/JunLiangWangX/js-algorithm/blob/main/133.CloneGraph.js) | 给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin)** 图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。 | Given a reference of a node in a **[connected](https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph)** undirected graph.Return a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) (clone) of the graph. |
| [#134](https://leetcode.cn/problems/gas-station/description/) | [GasStation](https://github.com/JunLiangWangX/js-algorithm/blob/main/134.GasStation.js) | 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 | There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique |
| [#136](https://leetcode.cn/problems/single-number/description/) | [SingleNumber](https://github.com/JunLiangWangX/js-algorithm/blob/main/136.SingleNumber.js) | 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 | Given a **non-empty** array of integers `nums`, every element appears *twice* except for one. Find that single one. |
| [#137](https://leetcode.cn/problems/single-number-ii/description/) | [SingleNumberII](https://github.com/JunLiangWangX/js-algorithm/blob/main/137.SingleNumberII.js) | 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现三次。找出那个只出现了一次的元素。 | Given a **non-empty** array of integers `nums`, every element appears thrid except for one. Find that single one. |
| [#138](https://leetcode.cn/problems/copy-list-with-random-pointer/description/) | [CopyListwithRandomPointer](https://github.com/JunLiangWangX/js-algorithm/blob/main/138.CopyListwithRandomPointer.js) | 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态 | A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. |
| [#139](https://leetcode.cn/problems/word-break/description/) | [WordBreak](https://github.com/JunLiangWangX/js-algorithm/blob/main/139.WordBreak.js) | 给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。 | Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words. |
| [#140](https://leetcode.cn/problems/word-break-ii/description/) | [[WordBreakII]](https://github.com/JunLiangWangX/js-algorithm/blob/main/140.WordBreakII.js) | 给定一个字符串 `s` 和一个字符串字典 `wordDict` ，在字符串 `s` 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。**以任意顺序** 返回所有这些可能的句子。 | Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**. |
| [#141](https://leetcode.cn/problems/linked-list-cycle/description/) | [LinkedListCycle](https://github.com/JunLiangWangX/js-algorithm/blob/main/141.LinkedListCycle.js) | 给你一个链表的头节点 head ，判断链表中是否有环。             | Given `head`, the head of a linked list, determine if the linked list has a cycle in it. |
| [#142](https://leetcode.cn/problems/linked-list-cycle-ii/description/) | [LinkedListCycleII](https://github.com/JunLiangWangX/js-algorithm/blob/main/142.LinkedListCycleII.js) | 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 | Given the `head` of a linked list, return *the node where the cycle begins. If there is no cycle, return* `null`. |
| [#143](https://leetcode.cn/problems/reorder-list/description/) | [ReorderList](https://github.com/JunLiangWangX/js-algorithm/blob/main/143.ReorderList.js) | 重排链表                                                     | Reorder list                                                 |
| [#144](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/) | [BinaryTreePreorderTraversal](https://github.com/JunLiangWangX/js-algorithm/blob/main/144.BinaryTreePreorderTraversal.js) | 给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。   | Given the `root` of a binary tree, return *the preorder traversal of its nodes' values*. |
| [#145](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/) | [BinaryTreePostorderTraversal](https://github.com/JunLiangWangX/js-algorithm/blob/main/145.BinaryTreePostorderTraversal.js) | 给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。 | Given the `root` of a binary tree, return *the postorder traversal of its nodes' values*. |
| [#146](https://leetcode.cn/problems/lru-cache/)              | [LRUCache](https://github.com/JunLiangWangX/js-algorithm/blob/main/146.LRUCache.js) | 请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。 | Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. |
| [#147](https://leetcode.cn/problems/insertion-sort-list/description/) | [InsertionSortList](https://github.com/JunLiangWangX/js-algorithm) | 给定单个链表的头 `head` ，使用 **插入排序** 对链表进行排序，并返回 *排序后链表的头* 。 | Given the `head` of a singly linked list, sort the list using **insertion sort**, and return *the sorted list's head*. |
| [#148](https://leetcode.cn/problems/sort-list/description/)  | [SortList](https://github.com/JunLiangWangX/js-algorithm/blob/main/148.SortList.js) | 给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。 | Given the `head` of a linked list, return *the list after sorting it in **ascending order***. |



