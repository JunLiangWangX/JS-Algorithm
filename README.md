# js-algorithm
Use js to implement leetcode algorithm

| 题目编号(topic number)                                       | 文件名(file name)                                            | 描述                                                         | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1~50                                                         | [General-Questions-Part1](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part1) | 普通题：题1到题50归档集合                                    | GeneralQuestion：Question 1 to Question 50 archive collection |
| 51~100                                                       | [General-Questions-Part2](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part2) | 普通题：题51到题100归档集合                                  | GeneralQuestion：Question 51 to Question 100 archive collection |
| [#101](https://leetcode.cn/problems/symmetric-tree/)         | [SymmetricTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/101.SymmetricTree.js) | 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。          | Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). |
| [#102](https://leetcode.cn/problems/binary-tree-level-order-traversal/) | [BinaryTreeLevelOrderTraversal](https://github.com/JunLiangWangX/js-algorithm/blob/main/102.BinaryTreeLevelOrderTraversal.js) | 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。 | Given the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level). |
| [#103](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/) | [BinaryTreeZigzagLevelOrder....](https://github.com/JunLiangWangX/js-algorithm/blob/main/103.BinaryTreeZigzagLevelOrderTraversal.js) | 给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 | Given the `root` of a binary tree, return *the zigzag level order traversal of its nodes' values*. (i.e., from left to right, then right to left for the next level and alternate between). |
| [#104](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | [MaximumDepthofBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/104.MaximumDepthofBinaryTree.js) | 给定一个二叉树 `root` ，返回其最大深度。                     | Given the `root` of a binary tree, return *its maximum depth*. |
| [#105](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | [ConstructBinaryTree....](https://github.com/JunLiangWangX/js-algorithm/blob/main/105.ConstructBinaryTreefromPreorderandInorderTraversal.js) | 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。 | Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return *the binary tree*. |
| [#106](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/) | [ConstructBinaryTree....](https://github.com/JunLiangWangX/js-algorithm/blob/main/106.ConstructBinaryTreefromInorderandPostorderTraversal.js) | 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。 | Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return *the binary tree*. |
| [#107](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/) | [BinaryTreeLevelOrderTraversalII](https://github.com/JunLiangWangX/js-algorithm/blob/main/107.BinaryTreeLevelOrderTraversalII.js) | 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） | Given the `root` of a binary tree, return *the bottom-up level order traversal of its nodes' values*. (i.e., from left to right, level by level from leaf to root). |
| [#108](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/) | [ConvertSortedArraytoBinary....](https://github.com/JunLiangWangX/js-algorithm/blob/main/108.ConvertSortedArraytoBinarySearchTree.js) | 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。 | Given an integer array `nums` where the elements are sorted in **ascending order**, convert *it to a* **height-balanced** *binary search tree*. |
| [#109](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/) | [ConvertSortedListtoBinary....](https://github.com/JunLiangWangX/js-algorithm/blob/main/109.ConvertSortedListtoBinarySearchTree.js) | 给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。 | Given the `head` of a singly linked list where elements are sorted in **ascending order**, convert *it to a* ***height-balanced\*** *binary search tree*. |
| [#110](https://leetcode.cn/problems/balanced-binary-tree/description/) | [BalancedBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/110.BalancedBinaryTree.js) | 给定一个二叉树，判断它是否是高度平衡的二叉树。               | Given a binary tree, determine if it is **height-balanced**. |
| [#111](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) | [MinimumDepthOfBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/111.MinimumDepthOfBinaryTree.js) | 给定一个二叉树，找出其最小深度。                             | Given a binary tree, find its minimum depth.                 |
| [#112](https://leetcode.cn/problems/path-sum/)               | [PathSum](https://github.com/JunLiangWangX/js-algorithm/blob/main/112.PathSum.js) | 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。 | Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`. |
| [#113](https://leetcode.cn/problems/path-sum-ii/)            | [PathSumII](https://github.com/JunLiangWangX/js-algorithm/blob/main/113.PathSumII.js) | 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。 | Given the `root` of a binary tree and an integer `targetSum`, return *all **root-to-leaf** paths where the sum of the node values in the path equals* `targetSum`*. Each path should be returned as a list of the node **values**, not node references*. |
| [#114](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/) | [FlattenBinaryTreetoLinkedList](https://github.com/JunLiangWangX/js-algorithm/blob/main/114.FlattenBinaryTreetoLinkedList.js) | 给你二叉树的根结点 `root` ，请你将它展开为一个单链表：       | Given the `root` of a binary tree, flatten the tree into a "linked list" |
| [#115](https://leetcode.cn/problems/distinct-subsequences/description/) | [DistinctSubsequences](https://github.com/JunLiangWangX/js-algorithm/blob/main/115.DistinctSubsequences.js) | 给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数。 | Given two strings `s` and `t`, return *the number of distinct* ***subsequences\*** *of* `s` *which equals* `t`. |
| [#116](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) | [PopulatingNextRightPointersin....](https://github.com/JunLiangWangX/js-algorithm/blob/main/116.PopulatingNextRightPointersinEachNode.js) | 给定一个 **完美二叉树**,填充它的每个 next 指针，让这个指针指向其下一个右侧节点。 | given a **perfect binary tree**,Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. |
| [#117](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/) | [PopulatingNextRightPointersin...II](https://github.com/JunLiangWangX/js-algorithm/blob/main/117.PopulatingNextRightPointersinEachNodeII.js) | 给定一个**二叉树**,填充它的每个 next 指针，让这个指针指向其下一个右侧节点。 | given a **binary tree**,Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. |
| [#118](https://leetcode.cn/problems/pascals-triangle/description/) | [Pascal'sTriangle](https://github.com/JunLiangWangX/js-algorithm/blob/main/118.Pascal'sTriangle.js) | 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。 | Given an integer `numRows`, return the first numRows of **Pascal's triangle**. |
| [#119](https://leetcode.cn/problems/pascals-triangle-ii/description/) | [[Pascal'sTriangleII](https://leetcode.cn/problems/pascals-triangle-ii/)](https://github.com/JunLiangWangX/js-algorithm/blob/main/119.Pascal'sTriangleII.js) | 给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。 | Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**. |
| [#120](https://leetcode.cn/problems/triangle/description/)   | [Triangle](https://github.com/JunLiangWangX/js-algorithm/blob/main/120.Triangle.js) | 给定一个三角形 `triangle` ，找出自顶向下的最小路径和。       | Given a `triangle` array, return *the minimum path sum from top to bottom*. |
| [#121](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/) | [BestTimetoBuyandSellStock](https://github.com/JunLiangWangX/js-algorithm/blob/main/121.BestTimetoBuyandSellStock.js) | 给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。 | You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock. |
| [#122](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/) | [BestTimetoBuyandSellStockII](https://github.com/JunLiangWangX/js-algorithm/blob/main/122.BestTimetoBuyandSellStockII.js) | 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。返回 *你能获得的 **最大** 利润* 。 | You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.On each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.Find and return *the **maximum** profit you can achieve*. |
| [#123](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) | [BestTimetoBuyandSellStockIII](https://github.com/JunLiangWangX/js-algorithm/blob/main/123.BestTimetoBuyandSellStockIII.js) | 给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。 | You are given an array prices where prices[i] is the price of a given stock on the ith day.Find the maximum profit you can achieve. You may complete at most two transactions. |



