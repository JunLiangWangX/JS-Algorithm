# js-algorithm

Use js to implement leetcode algorithm

| 题目编号(topic number)                                       | 文件名(file name)                                            | 描述                                                         | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1~50                                                         | [General-Questions-Part1](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part1) | 普通题：题1到题50归档集合                                    | GeneralQuestion：Question 1 to Question 50 archive collection |
| 51~100                                                       | [General-Questions-Part2](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part2) | 普通题：题51到题100归档集合                                  | GeneralQuestion：Question 51 to Question 100 archive collection |
| 101~150                                                      | [General-Questions-Part3](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part3) | 普通题：题101到题150归档集合                                 | GeneralQuestion：Question 101 to Question 150 archive collection |
| [#151](https://leetcode.cn/problems/reverse-words-in-a-string/) | [ReverseWordsString](https://github.com/JunLiangWangX/js-algorithm/blob/main/151.ReverseWordsString.js) | 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。      | Given an input string `s`, reverse the order of the **words**. |
| [#152](https://leetcode.cn/problems/maximum-product-subarray/) | [MaximumProductSubarray](https://github.com/JunLiangWangX/js-algorithm/blob/main/152.MaximumProductSubarray.js) | 给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 | Given an integer array `nums`, find a subarray that has the largest product, and return *the product*. |
| [#153](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/) | [FindMinimuminRotatedSortedArray](https://github.com/JunLiangWangX/js-algorithm/blob/main/153.FindMinimuminRotatedSortedArray.js) | 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。 | Given the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*. |
| [#154](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/description/) | [FindMinimuminRotatedSortedArrayII](https://github.com/JunLiangWangX/js-algorithm/blob/main/154.FindMinimuminRotatedSortedArrayII.js) | 给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。 | Given the sorted rotated array `nums` that may contain **duplicates**, return *the minimum element of this array*. |
| [#155](https://leetcode.cn/problems/min-stack/description/)  | [MinStack](https://github.com/JunLiangWangX/js-algorithm/blob/main/155.MinStack.js) | 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。 | Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. |
| [#169](https://leetcode.cn/problems/majority-element/description/) | [MajorityElement](https://github.com/JunLiangWangX/js-algorithm/blob/main/169.MajorityElement.js) | 给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。 | Given an array `nums` of size `n`, return *the majority element*. |
| [#189](https://leetcode.cn/problems/rotate-array/)           | [RotateArray](https://github.com/JunLiangWangX/js-algorithm/blob/main/189.RotateArray.js) | 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。 | Given an integer array nums, rotate the array to the right by k steps, where k is non-negative. |
| [#274](https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150) | [H-Index](https://github.com/JunLiangWangX/js-algorithm/blob/main/274.H-Index.js) | 给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。 | Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return *the researcher's h-index*. |
| [#380](https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150) | [InsertDeleteGetRandom](https://github.com/JunLiangWangX/js-algorithm/blob/main/380.InsertDeleteGetRandom.js) | 实现`RandomizedSet` 类                                       | Implement the `RandomizedSet` class                          |
| [#238](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150) | [ProductofArrayExceptSelf](https://github.com/JunLiangWangX/js-algorithm/blob/main/238.ProductofArrayExceptSelf.js) | 给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。 | Given an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.You must write an algorithm that runs in `O(n)` time and without using the division operation. |
| [#392](https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150) | [IsSubsequence](https://github.com/JunLiangWangX/js-algorithm/blob/main/392.IsSubsequence.js) | 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。 | Given two strings `s` and `t`, return `true` *if* `s` *is a **subsequence** of* `t`*, or* `false` *otherwise*. |
| [#167](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/) | [TwoSumII](https://github.com/JunLiangWangX/js-algorithm/blob/main/167.TwoSumII.js) | 给你一个整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。 | Given a array of integers `numbers` that is already ***sorted in non-decreasing order\***, find two numbers such that they add up to a specific `target` number. |
| [#209](https://leetcode.cn/problems/minimum-size-subarray-sum/) | [MinimumSizeSubarraySum](https://github.com/JunLiangWangX/js-algorithm/blob/main/209.MinimumSizeSubarraySum.js) | 给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** ，并返回其长度。 | Given an array of positive integers `nums` and a positive integer `target`, return *the **minimal length** of a* *subarray* *whose sum is greater than or equal to* `target`. |
| [#289](https://leetcode.cn/problems/game-of-life/description/?envType=study-plan-v2&envId=top-interview-150) | [GameofLife](https://github.com/JunLiangWangX/js-algorithm/blob/main/289.GameofLife.js) | 生命游戏                                                     | Game of Life                                                 |
| [#383](https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150) | [RansomNote](https://github.com/JunLiangWangX/js-algorithm/blob/main/383.RansomNote.js) | 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。 | Given two strings `ransomNote` and `magazine`, return `true` *if* `ransomNote` *can be constructed by using the letters from* `magazine` *and* `false` *otherwise*. |
| [#290](https://leetcode.cn/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150) | [WordPattern](https://github.com/JunLiangWangX/js-algorithm/blob/main/290.WordPattern.js) | 给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。 | Given a `pattern` and a string `s`, find if `s` follows the same pattern. |
| [#242](https://leetcode.cn/problems/valid-anagram/description/?envType=study-plan-v2&envId=top-interview-150) | [ValidAnagram](https://github.com/JunLiangWangX/js-algorithm/blob/main/242.ValidAnagram.js) | 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。 | Given two strings `s` and `t`, return `true` *if* `t` *is an anagram of* `s`*, and* `false` *otherwise*. |
| [#202](https://leetcode.cn/problems/happy-number/description/) | [HappyNumber](https://github.com/JunLiangWangX/js-algorithm/blob/main/202.HappyNumber.js) | 编写一个算法来判断一个数 `n` 是不是快乐数。                  | Write an algorithm to determine if a number `n` is happy.    |
| [#219](https://leetcode.cn/problems/contains-duplicate-ii/description/) | [ContainsDuplicateII](https://github.com/JunLiangWangX/js-algorithm/blob/main/219.ContainsDuplicateII.js) | 给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。 | Given an integer array `nums` and an integer `k`, return `true` *if there are two **distinct indices*** `i` *and* `j` *in the array such that* `nums[i] == nums[j]` *and* `abs(i - j) <= k`. |
| [#228](https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150) | [SummaryRanges](https://github.com/JunLiangWangX/js-algorithm/blob/main/228.SummaryRanges.js) | 给定一个  无重复元素 的 有序 整数数组 nums 。返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 | You are given a **sorted unique** integer array `nums`.A **range** `[a,b]` is the set of all integers from `a` to `b` (inclusive). |
| [#452](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&envId=top-interview-150) | [MinimumNumberofArrowstoBurstBalloons](https://github.com/JunLiangWangX/js-algorithm/blob/main/452.MinimumNumberofArrowstoBurstBalloons.js) | 合并区间交集                                                 | Merge Interval Intersections                                 |
| [#224](https://leetcode.cn/problems/basic-calculator/description/) | [BasicCalculator](https://github.com/JunLiangWangX/js-algorithm) | 给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。 | Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return *the result of the evaluation*. |
| [#226](https://leetcode.cn/problems/invert-binary-tree/description/) | [InvertBinaryTree](https://github.com/JunLiangWangX/js-algorithm) | 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。 | Given the `root` of a binary tree, invert the tree, and return *its root*. |
| [#173](https://leetcode.cn/problems/binary-search-tree-iterator/description/?envType=study-plan-v2&envId=top-interview-150) | [BinarySearchTreeIterator](https://github.com/JunLiangWangX/js-algorithm/blob/main/173.BinarySearchTreeIterator.js) | 实现一个二叉搜索树迭代器类`BSTIterator` ，表示一个按中序遍历二叉搜索树（BST）的迭代器 | Implement the `BSTIterator` class that represents an iterator over the **[in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))** of a binary search tree (BST) |
| [#222](https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&envId=top-interview-150) | [CountCompleteTreeNodes](https://github.com/JunLiangWangX/js-algorithm/blob/main/222.CountCompleteTreeNodes.js) | 给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。 | Given the `root` of a **complete** binary tree, return the number of the nodes in the tree. |
| [#236](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150) | [LowestCommonAncestorBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/236.LowestCommonAncestorBinaryTree.js) | 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。       | Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. |
| [#199](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-interview-150) | [BinaryTreeRightSideView](https://github.com/JunLiangWangX/js-algorithm/blob/main/199.BinaryTreeRightSideView.js) | 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 | Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return *the values of the nodes you can see ordered from top to bottom*. |
| [#637](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150) | [AverageofLevelsinBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/637.AverageofLevelsinBinaryTree.js) | 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。 | Given the `root` of a binary tree, return *the average value of the nodes on each level in the form of an array*. |
| [#530](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/) | [MinimumAbsoluteDifferenceinBST](https://github.com/JunLiangWangX/js-algorithm/blob/main/530.MinimumAbsoluteDifferenceinBST.js) | 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。 | Given the `root` of a Binary Search Tree (BST), return *the minimum absolute difference between the values of any two different nodes in the tree*. |
| [#230](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-interview-150) | [KthSmallestElementInBST](https://github.com/JunLiangWangX/js-algorithm/blob/main/230.KthSmallestElementInBST.js) | 给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。 | Given the `root` of a binary search tree, and an integer `k`, return *the* `kth` *smallest value (**1-indexed**) of all the values of the nodes in the tree*. |
| [#200](https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-interview-150) | [NumberofIslands](https://github.com/JunLiangWangX/js-algorithm/blob/main/200.NumberofIslands.js) | 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。 | Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*. |
| [#399](https://leetcode.cn/problems/evaluate-division/description/) | [EvaluateDivision](https://github.com/JunLiangWangX/js-algorithm/blob/main/399.EvaluateDivision.js) | 除法求值                                                     | Division evaluation                                          |
| [#207](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-interview-150) | [CourseSchedule](https://github.com/JunLiangWangX/js-algorithm/blob/main/207.CourseSchedule.js) | 判断有向图是否无环                                           | Determine whether a directed graph is acyclic                |
| [#210](https://leetcode.cn/problems/course-schedule-ii/description/?envType=study-plan-v2&envId=top-interview-150) | [CourseScheduleII](https://github.com/JunLiangWangX/js-algorithm/blob/main/210.CourseScheduleII.js) | 判断有向图是否无环，无环则返回其拓扑排序列表，否则返回空数组 | Determine whether the directed graph is acyclic. If it is acyclic, return its topologically sorted list. Otherwise, return an empty array. |
| [#909](https://leetcode.cn/problems/snakes-and-ladders/description/) | [SnakesAndLadders](https://github.com/JunLiangWangX/js-algorithm/blob/main/909.SnakesAndLadders.js) | 给定一个n*n的矩阵棋盘，方格按从 1 到 n^2 编号,排列顺序从左下角[n-1,0]开始，蛇形排列。玩家从1号方格出发，每次能够移动1到6格，当遇到的格子的值不为-1，则可以跳转到[格子的值]号格子，请问需要多少次能将棋移动到n^2号格子 | Given an n*n matrix chessboard, the squares are numbered from 1 to n^2, and the arrangement order starts from the lower left corner [n-1,0], arranged in a snake shape. The player starts from square No. 1 and can move 1 to 6 squares each time. When the value of the square encountered is not -1, he can jump to the square [value of square]. How many times does it take to move the chess to Grid No. n^2 |
| [#433](https://leetcode.cn/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150) | [MinimumGeneticMutation](https://github.com/JunLiangWangX/js-algorithm/blob/main/433.MinimumGeneticMutation.js) | 给你两个基因序列 `start` 和 `end` ，以及一个基因库 `bank` ，请你找出并返回能够使 `start` 变化为 `end` 所需的最少变化次数。如果无法完成此基因变化，返回 `-1` 。 | Given the two gene strings `startGene` and `endGene` and the gene bank `bank`, return *the minimum number of mutations needed to mutate from* `startGene` *to* `endGene`. If there is no such a mutation, return `-1`. |
| [#208](https://leetcode.cn/problems/implement-trie-prefix-tree/?envType=study-plan-v2&envId=top-interview-150) | [ImplementTrie(PrefixTree)](https://github.com/JunLiangWangX/js-algorithm/blob/main/208.ImplementTrie(PrefixTree).js) | 实现前缀树                                                   | Implement Trie (Prefix Tree)                                 |
| [#211](https://leetcode.cn/problems/design-add-and-search-words-data-structure/?envType=study-plan-v2&envId=top-interview-150) | [DesignAddSearchWordsDataStructure](https://github.com/JunLiangWangX/js-algorithm/blob/main/211.DesignAddSearchWordsDataStructure.js) | 请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。 | Design a data structure that supports adding new words and finding if a string matches any previously added string. |
| [#212](https://leetcode.cn/problems/word-search-ii/description/?envType=study-plan-v2&envId=top-interview-150) | [WordSearchII](https://github.com/JunLiangWangX/js-algorithm/blob/main/212.WordSearchII.js) | 给定一个 `m x n` 二维字符网格 `board` 和一个单词（字符串）列表 `words`， *返回所有二维网格上的单词* 。 | Given an `m x n` `board` of characters and a list of strings `words`, return *all words on the board*. |
| [#427](https://leetcode.cn/problems/construct-quad-tree/description/?envType=study-plan-v2&envId=top-interview-150) | [ConstructQuadTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/427.ConstructQuadTree.js) | 给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。 | Given a `n * n` matrix `grid` of `0's` and `1's` only. We want to represent `grid` with a Quad-Tree. |
| [#918](https://leetcode.cn/problems/maximum-sum-circular-subarray/description/?envType=study-plan-v2&envId=top-interview-150) | [MaximumSumCircularSubarray](https://github.com/JunLiangWangX/js-algorithm/blob/main/918.MaximumSumCircularSubarray.js) | 给定一个长度为 `n` 的**环形整数数组** `nums` ，返回 *`nums` 的非空 **子数组** 的最大可能和* 。 | Given a **circular integer array** `nums` of length `n`, return *the maximum possible sum of a non-empty **subarray** of* `nums`. |
| [#162](https://leetcode.cn/problems/find-peak-element/?envType=study-plan-v2&envId=top-interview-150) | [FindPeakElement](https://github.com/JunLiangWangX/js-algorithm/blob/main/162.FindPeakElement.js) | 给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。 | Given a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**. |
| [#215](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-interview-150) | [KthLargestElementInArray](https://github.com/JunLiangWangX/js-algorithm/blob/main/215.KthLargestElementInArray.js) | 给定整数数组 `nums` 和整数 `k`，请返回数组中第 k 个最大的元素。你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。 | Given an integer array `nums` and an integer `k`, return *the* `kth` *largest element in the array*. |
| [#502](https://leetcode.cn/problems/ipo/description/?envType=study-plan-v2&envId=top-interview-150) | [IPO](https://github.com/JunLiangWangX/js-algorithm/blob/main/502.IPO.js) | 给你 `n` 个项目。对于每个项目 `i` ，它都有一个纯利润 `profits[i]` ，和启动该项目需要的最小资本 `capital[i]` 。总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本** ，并输出最终可获得的最多资本。 | You are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.Pick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return *the final maximized capital*. |
| [#373](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/?envType=study-plan-v2&envId=top-interview-150) | [FindKPairswithSmallestSums](https://github.com/JunLiangWangX/js-algorithm/blob/main/373.FindKPairswithSmallestSums.js) | 给定两个以 **非递减顺序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。请找到和最小的 `k` 个数对 `(u1,v1)`, ` (u2,v2)` ...  `(uk,vk)` 。 | You are given two integer arrays `nums1` and `nums2` sorted in **non-decreasing order** and an integer `k`.Define a pair `(u, v)` which consists of one element from the first array and one element from the second array.Return *the* `k` *pairs* `(u1, v1), (u2, v2), ..., (uk, vk)` *with the smallest sums*. |
| [#295](https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-interview-150) | [FindMedianFromDataStream](https://github.com/JunLiangWangX/js-algorithm/blob/main/295.FindMedianFromDataStream.js) | 实现 MedianFinder 类                                         | Implement the MedianFinder class                             |
| [#190](https://leetcode.cn/problems/reverse-bits/description/?envType=study-plan-v2&envId=top-interview-150) | [ReverseBits](https://github.com/JunLiangWangX/js-algorithm/blob/main/190.ReverseBits.js) | 颠倒给定的 32 位无符号整数的二进制位。                       | Reverse bits of a given 32 bits unsigned integer.            |
| [#191](https://github.com/JunLiangWangX/js-algorithm/blob/main/191.NumberOf1Bits.js) | [NumberOf1Bits](https://leetcode.cn/problems/number-of-1-bits/description/?envType=study-plan-v2&envId=top-interview-150) | 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。 | Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)). |
| [#201](https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/?envType=study-plan-v2&envId=top-interview-150) | [BitwiseAndNumbersRange](https://github.com/JunLiangWangX/js-algorithm/blob/main/201.BitwiseAndNumbersRange.js) | 给你两个整数 `left` 和 `right` ，表示区间 `[left, right]` ，返回此区间内所有数字 **按位与** 的结果（包含 `left` 、`right` 端点）。 | Given two integers `left` and `right` that represent the range `[left, right]`, return *the bitwise AND of all numbers in this range, inclusive*. |
| [#172](https://leetcode.cn/problems/factorial-trailing-zeroes/description/?envType=study-plan-v2&envId=top-interview-150) | [FactorialTrailingZeroes](https://github.com/JunLiangWangX/js-algorithm/blob/main/172.FactorialTrailingZeroes.js) | 给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。            | Given an integer `n`, return *the number of trailing zeroes in* `n!`. |
| [#198](https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-interview-150) | [HouseRobber](https://github.com/JunLiangWangX/js-algorithm/blob/main/198.HouseRobber.js) | 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下(如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警) ，一夜之内能够偷窃到的最高金额。 | Given an array of non-negative integers representing the amount of money stored in each house, calculate how much money you can make in one night without triggering the alarm device (if two adjacent houses are broken into by thieves on the same night, the system will automatically alarm) Maximum amount stolen. |
| [#322](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-interview-150) | [CoinChange](https://github.com/JunLiangWangX/js-algorithm/blob/main/322.CoinChange.js) | 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。 | You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.Return *the fewest number of coins that you need to make up that amount*. If that amount of money cannot be made up by any combination of the coins, return `-1`. |

