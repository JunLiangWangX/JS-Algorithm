# js-algorithm

Use js to implement leetcode algorithm

| 题目编号(topic number)                                       | 文件名(file name)                                            | 描述                                                         | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1~50                                                         | [General-Questions-Part1](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part1) | 普通题：题1到题50归档集合                                    | GeneralQuestion：Question 1 to Question 50 archive collection |
| 51~100                                                       | [General-Questions-Part2](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part2) | 普通题：题51到题100归档集合                                  | GeneralQuestion：Question 51 to Question 100 archive collection |
| 101~150                                                      | [General-Questions-Part3](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part3) | 普通题：题101到题150归档集合                                 | GeneralQuestion：Question 101 to Question 150 archive collection |
| [#151](https://leetcode.cn/problems/reverse-words-in-a-string/) | [ReverseWordsString](https://github.com/JunLiangWangX/js-algorithm/blob/main/151.ReverseWordsString.js) | 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。      | Given an input string `s`, reverse the order of the **words**. |
| [#152](https://leetcode.cn/problems/maximum-product-subarray/) | [MaximumProductSubarray](https://github.com/JunLiangWangX/js-algorithm/blob/main/152.MaximumProductSubarray.js) | 给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 | Given an integer array `nums`, find a subarray that has the largest product, and return *the product*. |
| [#153](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/) | [FindMinimuminRotatedSortedArray](https://github.com/JunLiangWangX/js-algorithm/blob/main/153.FindMinimuminRotatedSortedArray.js) | 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。 | Given the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*. |
| [#154](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/description/) | [FindMinimuminRotatedSortedArrayII](https://github.com/JunLiangWangX/js-algorithm/blob/main/154.FindMinimuminRotatedSortedArrayII.js) | 给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。 | Given the sorted rotated array `nums` that may contain **duplicates**, return *the minimum element of this array*. |
| [#155](https://leetcode.cn/problems/min-stack/description/)  | [MinStack](https://github.com/JunLiangWangX/js-algorithm/blob/main/155.MinStack.js) | 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。 | Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. |
| [#169](https://leetcode.cn/problems/majority-element/description/) | [MajorityElement](https://github.com/JunLiangWangX/js-algorithm/blob/main/169.MajorityElement.js) | 给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。 | Given an array `nums` of size `n`, return *the majority element*. |
| [#189](https://leetcode.cn/problems/rotate-array/)           | [RotateArray](https://github.com/JunLiangWangX/js-algorithm/blob/main/189.RotateArray.js) | 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。 | Given an integer array nums, rotate the array to the right by k steps, where k is non-negative. |
| [#274](https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150) | [H-Index](https://github.com/JunLiangWangX/js-algorithm/blob/main/274.H-Index.js) | 给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。 | Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return *the researcher's h-index*. |
| [#380](https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150) | [InsertDeleteGetRandom](https://github.com/JunLiangWangX/js-algorithm/blob/main/380.InsertDeleteGetRandom.js) | 实现`RandomizedSet` 类                                       | Implement the `RandomizedSet` class                          |
| [#238](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150) | [ProductofArrayExceptSelf](https://github.com/JunLiangWangX/js-algorithm/blob/main/238.ProductofArrayExceptSelf.js) | 给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。 | Given an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.You must write an algorithm that runs in `O(n)` time and without using the division operation. |
| [#392](https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150) | [IsSubsequence](https://github.com/JunLiangWangX/js-algorithm/blob/main/392.IsSubsequence.js) | 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。 | Given two strings `s` and `t`, return `true` *if* `s` *is a **subsequence** of* `t`*, or* `false` *otherwise*. |
| [#167](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/) | [TwoSumII](https://github.com/JunLiangWangX/js-algorithm/blob/main/167.TwoSumII.js) | 给你一个整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。 | Given a array of integers `numbers` that is already ***sorted in non-decreasing order\***, find two numbers such that they add up to a specific `target` number. |
| [#209](https://leetcode.cn/problems/minimum-size-subarray-sum/) | [MinimumSizeSubarraySum](https://github.com/JunLiangWangX/js-algorithm/blob/main/209.MinimumSizeSubarraySum.js) | 给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** ，并返回其长度。 | Given an array of positive integers `nums` and a positive integer `target`, return *the **minimal length** of a* *subarray* *whose sum is greater than or equal to* `target`. |
| [#289](https://leetcode.cn/problems/game-of-life/description/?envType=study-plan-v2&envId=top-interview-150) | [GameofLife](https://github.com/JunLiangWangX/js-algorithm/blob/main/289.GameofLife.js) | 生命游戏                                                     | Game of Life                                                 |
| [#383](https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150) | [RansomNote](https://github.com/JunLiangWangX/js-algorithm/blob/main/383.RansomNote.js) | 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。 | Given two strings `ransomNote` and `magazine`, return `true` *if* `ransomNote` *can be constructed by using the letters from* `magazine` *and* `false` *otherwise*. |
| [#290](https://leetcode.cn/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150) | [WordPattern](https://github.com/JunLiangWangX/js-algorithm/blob/main/290.WordPattern.js) | 给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。 | Given a `pattern` and a string `s`, find if `s` follows the same pattern. |
| [#242](https://leetcode.cn/problems/valid-anagram/description/?envType=study-plan-v2&envId=top-interview-150) | [ValidAnagram](https://github.com/JunLiangWangX/js-algorithm/blob/main/242.ValidAnagram.js) | 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。 | Given two strings `s` and `t`, return `true` *if* `t` *is an anagram of* `s`*, and* `false` *otherwise*. |
| [#202](https://leetcode.cn/problems/happy-number/description/) | [HappyNumber](https://github.com/JunLiangWangX/js-algorithm/blob/main/202.HappyNumber.js) | 编写一个算法来判断一个数 `n` 是不是快乐数。                  | Write an algorithm to determine if a number `n` is happy.    |
| [#219](https://leetcode.cn/problems/contains-duplicate-ii/description/) | [ContainsDuplicateII](https://github.com/JunLiangWangX/js-algorithm/blob/main/219.ContainsDuplicateII.js) | 给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。 | Given an integer array `nums` and an integer `k`, return `true` *if there are two **distinct indices*** `i` *and* `j` *in the array such that* `nums[i] == nums[j]` *and* `abs(i - j) <= k`. |
| [#228](https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150) | [SummaryRanges](https://github.com/JunLiangWangX/js-algorithm/blob/main/228.SummaryRanges.js) | 给定一个  无重复元素 的 有序 整数数组 nums 。返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 | You are given a **sorted unique** integer array `nums`.A **range** `[a,b]` is the set of all integers from `a` to `b` (inclusive). |
| [#452](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&envId=top-interview-150) | [MinimumNumberofArrowstoBurstBalloons](https://github.com/JunLiangWangX/js-algorithm/blob/main/452.MinimumNumberofArrowstoBurstBalloons.js) | 合并区间交集                                                 | Merge Interval Intersections                                 |
| [#224](https://leetcode.cn/problems/basic-calculator/description/) | [BasicCalculator](https://github.com/JunLiangWangX/js-algorithm) | 给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。 | Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return *the result of the evaluation*. |
| [#226](https://leetcode.cn/problems/invert-binary-tree/description/) | [InvertBinaryTree](https://github.com/JunLiangWangX/js-algorithm) | 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。 | Given the `root` of a binary tree, invert the tree, and return *its root*. |
| [#173](https://leetcode.cn/problems/binary-search-tree-iterator/description/?envType=study-plan-v2&envId=top-interview-150) | [BinarySearchTreeIterator](https://github.com/JunLiangWangX/js-algorithm/blob/main/173.BinarySearchTreeIterator.js) | 实现一个二叉搜索树迭代器类`BSTIterator` ，表示一个按中序遍历二叉搜索树（BST）的迭代器 | Implement the `BSTIterator` class that represents an iterator over the **[in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))** of a binary search tree (BST) |
| [#222](https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&envId=top-interview-150) | [CountCompleteTreeNodes](https://github.com/JunLiangWangX/js-algorithm/blob/main/222.CountCompleteTreeNodes.js) | 给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。 | Given the `root` of a **complete** binary tree, return the number of the nodes in the tree. |
| [#236](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150) | [LowestCommonAncestorBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/236.LowestCommonAncestorBinaryTree.js) | 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。       | Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. |
| [#199](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-interview-150) | [BinaryTreeRightSideView](https://github.com/JunLiangWangX/js-algorithm/blob/main/199.BinaryTreeRightSideView.js) | 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 | Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return *the values of the nodes you can see ordered from top to bottom*. |
| [#637](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150) | [AverageofLevelsinBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/637.AverageofLevelsinBinaryTree.js) | 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。 | Given the `root` of a binary tree, return *the average value of the nodes on each level in the form of an array*. |
| [#530](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/) | [MinimumAbsoluteDifferenceinBST](https://github.com/JunLiangWangX/js-algorithm/blob/main/530.MinimumAbsoluteDifferenceinBST.js) | 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。 | Given the `root` of a Binary Search Tree (BST), return *the minimum absolute difference between the values of any two different nodes in the tree*. |
| [#230](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-interview-150) | [KthSmallestElementInBST](https://github.com/JunLiangWangX/js-algorithm/blob/main/230.KthSmallestElementInBST.js) | 给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。 | Given the `root` of a binary search tree, and an integer `k`, return *the* `kth` *smallest value (**1-indexed**) of all the values of the nodes in the tree*. |
| [#200](https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-interview-150) | [NumberofIslands](https://github.com/JunLiangWangX/js-algorithm/blob/main/200.NumberofIslands.js) | 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。 | Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*. |
| [#399](https://leetcode.cn/problems/evaluate-division/description/) | [EvaluateDivision](https://github.com/JunLiangWangX/js-algorithm/blob/main/399.EvaluateDivision.js) | 除法求值                                                     | Division evaluation                                          |
| [#207](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-interview-150) | [CourseSchedule](https://github.com/JunLiangWangX/js-algorithm/blob/main/207.CourseSchedule.js) | 判断有向图是否无环                                           | Determine whether a directed graph is acyclic                |
| [#210](https://leetcode.cn/problems/course-schedule-ii/description/?envType=study-plan-v2&envId=top-interview-150) | [CourseScheduleII](https://github.com/JunLiangWangX/js-algorithm/blob/main/210.CourseScheduleII.js) | 判断有向图是否无环，无环则返回其拓扑排序列表，否则返回空数组 | Determine whether the directed graph is acyclic. If it is acyclic, return its topologically sorted list. Otherwise, return an empty array. |
| [#909](https://leetcode.cn/problems/snakes-and-ladders/description/) | [SnakesAndLadders](https://github.com/JunLiangWangX/js-algorithm/blob/main/909.SnakesAndLadders.js) | 给定一个n*n的矩阵棋盘，方格按从 1 到 n^2 编号,排列顺序从左下角[n-1,0]开始，蛇形排列。玩家从1号方格出发，每次能够移动1到6格，当遇到的格子的值不为-1，则可以跳转到[格子的值]号格子，请问需要多少次能将棋移动到n^2号格子 | Given an n*n matrix chessboard, the squares are numbered from 1 to n^2, and the arrangement order starts from the lower left corner [n-1,0], arranged in a snake shape. The player starts from square No. 1 and can move 1 to 6 squares each time. When the value of the square encountered is not -1, he can jump to the square [value of square]. How many times does it take to move the chess to Grid No. n^2 |
| [#433](https://leetcode.cn/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150) | [MinimumGeneticMutation](https://github.com/JunLiangWangX/js-algorithm/blob/main/433.MinimumGeneticMutation.js) | 给你两个基因序列 `start` 和 `end` ，以及一个基因库 `bank` ，请你找出并返回能够使 `start` 变化为 `end` 所需的最少变化次数。如果无法完成此基因变化，返回 `-1` 。 | Given the two gene strings `startGene` and `endGene` and the gene bank `bank`, return *the minimum number of mutations needed to mutate from* `startGene` *to* `endGene`. If there is no such a mutation, return `-1`. |
| [#208](https://leetcode.cn/problems/implement-trie-prefix-tree/?envType=study-plan-v2&envId=top-interview-150) | [ImplementTrie(PrefixTree)](https://github.com/JunLiangWangX/js-algorithm/blob/main/208.ImplementTrie(PrefixTree).js) | 实现前缀树                                                   | Implement Trie (Prefix Tree)                                 |
| [#211](https://leetcode.cn/problems/design-add-and-search-words-data-structure/?envType=study-plan-v2&envId=top-interview-150) | [DesignAddSearchWordsDataStructure](https://github.com/JunLiangWangX/js-algorithm/blob/main/211.DesignAddSearchWordsDataStructure.js) | 请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。 | Design a data structure that supports adding new words and finding if a string matches any previously added string. |
| [#212](https://leetcode.cn/problems/word-search-ii/description/?envType=study-plan-v2&envId=top-interview-150) | [WordSearchII](https://github.com/JunLiangWangX/js-algorithm/blob/main/212.WordSearchII.js) | 给定一个 `m x n` 二维字符网格 `board` 和一个单词（字符串）列表 `words`， *返回所有二维网格上的单词* 。 | Given an `m x n` `board` of characters and a list of strings `words`, return *all words on the board*. |

