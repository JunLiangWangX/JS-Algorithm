# js-algorithm
Use js to implement leetcode algorithm

| 题目编号(topic number)                                       | 文件名(file name)                                            | 描述                                                         | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1~50                                                         | [General-Questions-Part1](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part1) | 普通题：题1到题50归档集合                                    | GeneralQuestion：Question 1 to Question 50 archive collection |
| 51~100                                                       | [General-Questions-Part2](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part2) | 普通题：题51到题100归档集合                                  | GeneralQuestion：Question 51 to Question 100 archive collection |
| [#101](https://leetcode.cn/problems/symmetric-tree/)         | [SymmetricTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/101.SymmetricTree.js) | 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。          | Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). |
| [#102](https://leetcode.cn/problems/binary-tree-level-order-traversal/) | [BinaryTreeLevelOrderTraversal](https://github.com/JunLiangWangX/js-algorithm/blob/main/102.BinaryTreeLevelOrderTraversal.js) | 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。 | Given the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level). |
| [#103](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/) | [BinaryTreeZigzagLevelOrder....](https://github.com/JunLiangWangX/js-algorithm/blob/main/103.BinaryTreeZigzagLevelOrderTraversal.js) | 给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 | Given the `root` of a binary tree, return *the zigzag level order traversal of its nodes' values*. (i.e., from left to right, then right to left for the next level and alternate between). |
| [#104](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | [MaximumDepthofBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/104.MaximumDepthofBinaryTree.js) | 给定一个二叉树 `root` ，返回其最大深度。                     | Given the `root` of a binary tree, return *its maximum depth*. |
| [#105](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | [ConstructBinaryTree....](https://github.com/JunLiangWangX/js-algorithm/blob/main/105.ConstructBinaryTreefromPreorderandInorderTraversal.js) | 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。 | Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return *the binary tree*. |
| [#106](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/) | [ConstructBinaryTree....](https://github.com/JunLiangWangX/js-algorithm/blob/main/106.ConstructBinaryTreefromInorderandPostorderTraversal.js) | 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。 | Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return *the binary tree*. |
| [#107](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/) | [BinaryTreeLevelOrderTraversalII](https://github.com/JunLiangWangX/js-algorithm/blob/main/107.BinaryTreeLevelOrderTraversalII.js) | 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） | Given the `root` of a binary tree, return *the bottom-up level order traversal of its nodes' values*. (i.e., from left to right, level by level from leaf to root). |
| [#108](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/) | [ConvertSortedArraytoBinary....](https://github.com/JunLiangWangX/js-algorithm/blob/main/108.ConvertSortedArraytoBinarySearchTree.js) | 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。 | Given an integer array `nums` where the elements are sorted in **ascending order**, convert *it to a* **height-balanced** *binary search tree*. |
| [#109](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/) | [ConvertSortedListtoBinary....](https://github.com/JunLiangWangX/js-algorithm/blob/main/109.ConvertSortedListtoBinarySearchTree.js) | 给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。 | Given the `head` of a singly linked list where elements are sorted in **ascending order**, convert *it to a* ***height-balanced\*** *binary search tree*. |
| [#110](https://leetcode.cn/problems/balanced-binary-tree/description/) | [BalancedBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/110.BalancedBinaryTree.js) | 给定一个二叉树，判断它是否是高度平衡的二叉树。               | Given a binary tree, determine if it is **height-balanced**. |



