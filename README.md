# js-algorithm
Use js to implement leetcode algorithm

| 题目编号(topic number)                                       | 文件名(file name)                                            | 描述                                                         | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1~50                                                         | [General-Questions-Part1](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part1) | 普通题：题1到题50归档集合                                    | GeneralQuestion：Question 1 to Question 50 archive collection |
| 51~100                                                       | [General-Questions-Part2](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part2) | 普通题：题51到题100归档集合                                  | GeneralQuestion：Question 51 to Question 100 archive collection |
| [#101](https://leetcode.cn/problems/symmetric-tree/)         | [SymmetricTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/101.SymmetricTree.js) | 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。          | Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). |
| [#102](https://leetcode.cn/problems/binary-tree-level-order-traversal/) | [BinaryTreeLevelOrderTraversal](https://github.com/JunLiangWangX/js-algorithm/blob/main/102.BinaryTreeLevelOrderTraversal.js) | 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。 | Given the `root` of a binary tree, return *the level order traversal of its nodes' values*. (i.e., from left to right, level by level). |
| [#103](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/) | [BinaryTreeZigzagLevelOrder....](https://github.com/JunLiangWangX/js-algorithm/blob/main/103.BinaryTreeZigzagLevelOrderTraversal.js) | 给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 | Given the `root` of a binary tree, return *the zigzag level order traversal of its nodes' values*. (i.e., from left to right, then right to left for the next level and alternate between). |
| [#104](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | [MaximumDepthofBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/104.MaximumDepthofBinaryTree.js) | 给定一个二叉树 `root` ，返回其最大深度。                     | Given the `root` of a binary tree, return *its maximum depth*. |
| [#105](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | [ConstructBinaryTree....](https://github.com/JunLiangWangX/js-algorithm/blob/main/105.ConstructBinaryTreefromPreorderandInorderTraversal.js) | 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。 | Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return *the binary tree*. |
| [#106](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/) | [ConstructBinaryTree....](https://github.com/JunLiangWangX/js-algorithm/blob/main/106.ConstructBinaryTreefromInorderandPostorderTraversal.js) | 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。 | Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return *the binary tree*. |
| [#107](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/) | [BinaryTreeLevelOrderTraversalII](https://github.com/JunLiangWangX/js-algorithm/blob/main/107.BinaryTreeLevelOrderTraversalII.js) | 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） | Given the `root` of a binary tree, return *the bottom-up level order traversal of its nodes' values*. (i.e., from left to right, level by level from leaf to root). |
| [#108](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/) | [ConvertSortedArraytoBinary....](https://github.com/JunLiangWangX/js-algorithm/blob/main/108.ConvertSortedArraytoBinarySearchTree.js) | 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。 | Given an integer array `nums` where the elements are sorted in **ascending order**, convert *it to a* **height-balanced** *binary search tree*. |
| [#109](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/) | [ConvertSortedListtoBinary....](https://github.com/JunLiangWangX/js-algorithm/blob/main/109.ConvertSortedListtoBinarySearchTree.js) | 给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。 | Given the `head` of a singly linked list where elements are sorted in **ascending order**, convert *it to a* ***height-balanced\*** *binary search tree*. |
| [#110](https://leetcode.cn/problems/balanced-binary-tree/description/) | [BalancedBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/110.BalancedBinaryTree.js) | 给定一个二叉树，判断它是否是高度平衡的二叉树。               | Given a binary tree, determine if it is **height-balanced**. |
| [#111](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) | [MinimumDepthOfBinaryTree](https://github.com/JunLiangWangX/js-algorithm/blob/main/111.MinimumDepthOfBinaryTree.js) | 给定一个二叉树，找出其最小深度。                             | Given a binary tree, find its minimum depth.                 |
| [#112](https://leetcode.cn/problems/path-sum/)               | [PathSum](https://github.com/JunLiangWangX/js-algorithm/blob/main/112.PathSum.js) | 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。 | Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`. |
| [#113](https://leetcode.cn/problems/path-sum-ii/)            | [PathSumII](https://github.com/JunLiangWangX/js-algorithm/blob/main/113.PathSumII.js) | 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。 | Given the `root` of a binary tree and an integer `targetSum`, return *all **root-to-leaf** paths where the sum of the node values in the path equals* `targetSum`*. Each path should be returned as a list of the node **values**, not node references*. |
| [#114](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/) | [FlattenBinaryTreetoLinkedList](https://github.com/JunLiangWangX/js-algorithm/blob/main/114.FlattenBinaryTreetoLinkedList.js) | 给你二叉树的根结点 `root` ，请你将它展开为一个单链表：       | Given the `root` of a binary tree, flatten the tree into a "linked list" |
| [#115](https://leetcode.cn/problems/distinct-subsequences/description/) | [DistinctSubsequences](https://github.com/JunLiangWangX/js-algorithm/blob/main/115.DistinctSubsequences.js) | 给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数。 | Given two strings `s` and `t`, return *the number of distinct* ***subsequences\*** *of* `s` *which equals* `t`. |
| [#116](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) | [PopulatingNextRightPointersinEachNode](https://github.com/JunLiangWangX/js-algorithm/blob/main/116.PopulatingNextRightPointersinEachNode.js) | 给定一个 **完美二叉树**,填充它的每个 next 指针，让这个指针指向其下一个右侧节点。 | given a **perfect binary tree**,Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. |



