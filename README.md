# js-algorithm

Use js to implement leetcode algorithm

| 题目编号(topic number)                                       | 文件名(file name)                                            | 描述                                                         | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1~50                                                         | [General-Questions-Part1](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part1) | 普通题：题1到题50归档集合                                    | GeneralQuestion：Question 1 to Question 50 archive collection |
| 51~100                                                       | [General-Questions-Part2](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part2) | 普通题：题51到题100归档集合                                  | GeneralQuestion：Question 51 to Question 100 archive collection |
| 101~150                                                      | [General-Questions-Part3](https://github.com/JunLiangWangX/js-algorithm/tree/main/General-Questions-Part3) | 普通题：题101到题150归档集合                                 | GeneralQuestion：Question 101 to Question 150 archive collection |
| [#151](https://leetcode.cn/problems/reverse-words-in-a-string/) | [ReverseWordsString](https://github.com/JunLiangWangX/js-algorithm/blob/main/151.ReverseWordsString.js) | 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。      | Given an input string `s`, reverse the order of the **words**. |
| [#152](https://leetcode.cn/problems/maximum-product-subarray/) | [MaximumProductSubarray](https://github.com/JunLiangWangX/js-algorithm/blob/main/152.MaximumProductSubarray.js) | 给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 | Given an integer array `nums`, find a subarray that has the largest product, and return *the product*. |
| [#153](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/) | [FindMinimuminRotatedSortedArray](https://github.com/JunLiangWangX/js-algorithm/blob/main/153.FindMinimuminRotatedSortedArray.js) | 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。 | Given the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*. |
| [#154](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/description/) | [FindMinimuminRotatedSortedArrayII](https://github.com/JunLiangWangX/js-algorithm/blob/main/154.FindMinimuminRotatedSortedArrayII.js) | 给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。 | Given the sorted rotated array `nums` that may contain **duplicates**, return *the minimum element of this array*. |
| [#155](https://leetcode.cn/problems/min-stack/description/)  | [MinStack](https://github.com/JunLiangWangX/js-algorithm/blob/main/155.MinStack.js) | 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。 | Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. |
| [#169](https://leetcode.cn/problems/majority-element/description/) | [MajorityElement](https://github.com/JunLiangWangX/js-algorithm/blob/main/169.MajorityElement.js) | 给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。 | Given an array `nums` of size `n`, return *the majority element*. |
| [#189](https://leetcode.cn/problems/rotate-array/)           | [RotateArray](https://github.com/JunLiangWangX/js-algorithm/blob/main/189.RotateArray.js) | 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。 | Given an integer array nums, rotate the array to the right by k steps, where k is non-negative. |
| [#274](https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150) | [H-Index](https://github.com/JunLiangWangX/js-algorithm/blob/main/274.H-Index.js) | 给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。 | Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return *the researcher's h-index*. |
| [#380](https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150) | [InsertDeleteGetRandom](https://github.com/JunLiangWangX/js-algorithm/blob/main/380.InsertDeleteGetRandom.js) | 实现`RandomizedSet` 类                                       | Implement the `RandomizedSet` class                          |
| [#238](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150) | [ProductofArrayExceptSelf](https://github.com/JunLiangWangX/js-algorithm/blob/main/238.ProductofArrayExceptSelf.js) | 给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。请 **不要使用除法，**且在 `O(*n*)` 时间复杂度内完成此题。 | Given an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.You must write an algorithm that runs in `O(n)` time and without using the division operation. |
| [#392](https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150) | [IsSubsequence](https://github.com/JunLiangWangX/js-algorithm/blob/main/392.IsSubsequence.js) | 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。 | Given two strings `s` and `t`, return `true` *if* `s` *is a **subsequence** of* `t`*, or* `false` *otherwise*. |
| [#167](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/) | [TwoSumII](https://github.com/JunLiangWangX/js-algorithm/blob/main/167.TwoSumII.js) | 给你一个整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。 | Given a array of integers `numbers` that is already ***sorted in non-decreasing order\***, find two numbers such that they add up to a specific `target` number. |
| [#209](https://leetcode.cn/problems/minimum-size-subarray-sum/) | [MinimumSizeSubarraySum](https://github.com/JunLiangWangX/js-algorithm/blob/main/209.MinimumSizeSubarraySum.js) | 给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** ，并返回其长度。 | Given an array of positive integers `nums` and a positive integer `target`, return *the **minimal length** of a* *subarray* *whose sum is greater than or equal to* `target`. |
| [#289](https://leetcode.cn/problems/game-of-life/description/?envType=study-plan-v2&envId=top-interview-150) | [GameofLife](https://github.com/JunLiangWangX/js-algorithm/blob/main/289.GameofLife.js) | 生命游戏                                                     | Game of Life                                                 |
| [#383](https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150) | [RansomNote](https://github.com/JunLiangWangX/js-algorithm/blob/main/383.RansomNote.js) | 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。 | Given two strings `ransomNote` and `magazine`, return `true` *if* `ransomNote` *can be constructed by using the letters from* `magazine` *and* `false` *otherwise*. |
| [#290](https://leetcode.cn/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150) | [WordPattern](https://github.com/JunLiangWangX/js-algorithm/blob/main/290.WordPattern.js) | 给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。 | Given a `pattern` and a string `s`, find if `s` follows the same pattern. |
| [#242](https://leetcode.cn/problems/valid-anagram/description/?envType=study-plan-v2&envId=top-interview-150) | [ValidAnagram](https://github.com/JunLiangWangX/js-algorithm/blob/main/242.ValidAnagram.js) | 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。 | Given two strings `s` and `t`, return `true` *if* `t` *is an anagram of* `s`*, and* `false` *otherwise*. |

